const fs = require("fs");
function solveTurnstileMin({ url, proxy, siteKey }) {
  return new Promise(async (resolve, reject) => {
    if (!url) return reject("Missing url parameter");
    if (!siteKey) return reject("Missing siteKey parameter");

    let context = null;
    let contextClosed = false;

    try {
      context = await global.browser
        .createBrowserContext({
          proxyServer: proxy ? `http://${proxy.host}:${proxy.port}` : undefined, // https://pptr.dev/api/puppeteer.browsercontextoptions
        })
        .catch(() => null);

      if (!context) return reject("Failed to create browser context");

      let isResolved = false;

      const closeContext = async () => {
        if (!contextClosed && context) {
          try {
            contextClosed = true;
            await context.close();
          } catch (err) {
            console.error("Error closing context:", err.message);
          }
        }
      };

      var cl = setTimeout(async () => {
        if (!isResolved) {
          await closeContext();
          reject("Timeout Error");
        }
      }, global.timeOut || 180000);
      const page = await context.newPage();

      if (proxy?.username && proxy?.password)
        await page.authenticate({
          username: proxy.username,
          password: proxy.password,
        });

      await page.setRequestInterception(true);

      page.on("request", async (request) => {
        if (
          [url, url + "/"].includes(request.url()) &&
          request.resourceType() === "document"
        ) {
          await request.respond({
            status: 200,
            contentType: "text/html",
            body: String(
              require("fs").readFileSync(require("path").join(__dirname, "../data/fakePage.html"))
            ).replace(/<site-key>/g, siteKey),
          });
        } else {
          await request.continue();
        }
      });

      await page.goto(url, {
        waitUntil: "domcontentloaded",
      });

      await page.waitForSelector('[name="cf-response"]', {
        timeout: 180000,
      });
      
      const token = await page.evaluate(() => {
        try {
          return document.querySelector('[name="cf-response"]').value;
        } catch (e) {
          return null;
        }
      });
      
      isResolved = true;
      clearTimeout(cl);
      await closeContext();
      if (!token || token.length < 10) return reject("Failed to get token");
      return resolve(token);
      
    } catch (e) {
      console.log(e);
      isResolved = true;
      clearTimeout(cl);
      if (context && !contextClosed) {
        try {
          contextClosed = true;
          await context.close();
        } catch (err) {
          console.error("Error closing context:", err.message);
        }
      }
      reject(e.message);
    }
  });
}
module.exports = solveTurnstileMin;