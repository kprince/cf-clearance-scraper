function solveTurnstileMin({ url, proxy, siteKey }) {
  return new Promise(async (resolve, reject) => {
    if (!url) return reject("Missing url parameter");
    if (!siteKey) return reject("Missing siteKey parameter");

    let context = null;
    let contextClosed = false;
    
    try {
      context = await global.browser
        .createBrowserContext({
          proxyServer: proxy ? `http://${proxy.host}:${proxy.port}` : undefined, // https://pptr.dev/api/puppeteer.browsercontextoptions
        })
        .catch(() => null);
      
      if (!context) return reject("Failed to create browser context");

      let isResolved = false;

      const cl = setTimeout(async () => {
        if (!isResolved && !contextClosed) {
          try {
            contextClosed = true;
            await context.close();
          } catch (err) {
            console.error("Error closing context on timeout:", err.message);
          }
          reject("Timeout Error");
        }
      }, global.timeOut || 60000);

      try {
        const page = await context.newPage();

        if (proxy?.username && proxy?.password)
          await page.authenticate({
            username: proxy.username,
            password: proxy.password,
          });

        await page.setRequestInterception(true);

        page.on("request", async (request) => {
          if (
            [url, url + "/"].includes(request.url()) &&
            request.resourceType() === "document"
          ) {
            await request.respond({
              status: 200,
              contentType: "text/html",
              body: String(
                require("fs").readFileSync("./src/data/fakePage.html")
              ).replace(/<site-key>/g, siteKey),
            });
          } else {
            await request.continue();
          }
        });

        await page.goto(url, {
          waitUntil: "domcontentloaded",
        });

        await page.waitForSelector('[name="cf-response"]', {
          timeout: 60000,
        });

        const token = await page.evaluate(() => {
          try {
            return document.querySelector('[name="cf-response"]').value;
          } catch (e) {
            return null;
          }
        });

        isResolved = true;
        clearTimeout(cl);
        
        if (!contextClosed) {
          try {
            contextClosed = true;
            await context.close();
          } catch (err) {
            console.error("Error closing context after completion:", err.message);
          }
        }
        
        if (!token || token.length < 10) return reject("Failed to get token");
        resolve(token);
        
      } catch (err) {
        isResolved = true;
        clearTimeout(cl);
        
        if (!contextClosed) {
          try {
            contextClosed = true;
            await context.close();
          } catch (closeErr) {
            console.error("Error closing context after error:", closeErr.message);
          }
        }
        
        reject(err.message || "Unknown error");
      }
    } catch (err) {
      reject(err.message || "Failed to initialize browser context");
    }
  });
}
module.exports = solveTurnstileMin;
